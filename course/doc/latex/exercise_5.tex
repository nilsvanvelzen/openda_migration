
This exercise uses the same model as exercise~4: a model written in python that
describes the advection of two chemical species. Please read the start of
exercise~4 if you are not familiar with this model yet. A description of the
black box wrapper configuration, usually consisting of three xml files, can
also be found in exercise~4.

\begin{itemize}
\item Run the model from the command line, not using OpenDA, like in Exercise 4. The model
  generates the output files: {\tt reactive\_pollution\_model.output} and
  \\ {\tt reactive\_pollution\_model\_output.m}. Use the m-file to make plots
  of the output in order to study the behavior of the model. In order to check
  the model (plotted) results you can look at the input file as well.
\end{itemize}

%The Java-routines needed to access the model input and output files are the
%same as in exercise~4. Make sure that the jar-file is added to OpenDA, either
%by using the CLASSPATH environment variable or by copying the jar-file into the
%bin directory of your OpenDA version.

%TODO: add this lines once the oda_dump tool is working correctly....
%The utility oda\_dumpio assists in working with a black box wrapper in OpenDA.
%If you run {\tt oda\_dumpio.sh \textless jar-file\textgreater} it will list the
%available classes for reading and writing. In this case you should look for
%org.openda.mywrapper.myWrapper.\\

We start with some single and ensemble runs to understand where for our black
box wrapper configuration the model results appear:
\begin{itemize}

 \item Have a look at the files {\tt polluteWrapper.xml}, {\tt
   polluteModel.xml} and {\tt polluteStochModel.xml}, and look for differences compared to exercise\_4.
   Run the model within OpenDA by using
   the \\{\tt SequentialSimulation.oda} configuration. Use the script {\tt
   plot\_movie.m} (or {\tt plot\_movie.py} for python) to visualize the model 
   results. Compare the results with
   those from the run you executed without using OpenDA. Note that the actual
   model results are available in the directory where the black box wrapper has
   let the model perform its computation: {\tt stochModel/output/work0}.
 \item Run an ensemble forecast model by using the \\{\tt
   SequentialEnsembleSimulation.oda} configuration. On which variable does the
   algorithm impose stochastic forcing?\\ Have a look at the {\tt
     stochModel/output} directory, and note that the black box wrapper created
   the required ensemble members by repeatedly copying the template directory
   {\tt stochModel/input} to\\ {\tt stochModel/output/work\textless
     N\textgreater}.
 \item A special model instance is {\tt stochModel/output/work0}. It is the so
   called 'main' model, and is computed with the average of the perturbations
   of the ensemble members. Compare the results of {\tt
     stochModel/output/work0} with the results of {\tt
     SequentialSimulation.oda}. Note the relatively large differences. Check if
   these differences are reduced by increasing the ensemble size for the
   sequential ensemble simulation to 20 and rerunning {\tt
     SequentialEnsembleSimulation..oda} (this run may take a few minutes).
\end{itemize}

Now let us have a look at the configuration for performing OpenDA's Ensemble
Kalman Filtering on our black box model, using a twin experiment as an example.
The model has been run with the 'real' values (time dependent)for the
concentrations for substance 1 as disposed by factory 1 and factory 2. This
'truth' stored in the directory {\tt truthmodel}, and the results of that run
have been used to generate observation time series at the output locations.
These time series have been copied to the {\tt stochObserver} directory to
serve as observations for the filtering run.

The filter run takes the original model as input, which actually is a perturbed
version of the 'truth' model: the concentrations for substance 1 as disposed by
factories have been flattened out to a constant value. The filter process
should modify these values in such a way that the results resemble the truth as
much as possible.

To do this the filter modifies the concentration at factory 2, and uses the
observations downstream of factory 2 to optimize the forecast.

\begin{itemize}
 \item Note that the same black box configuration is used for the sequential
   run, the sequential ensemble run, and for the EnKF run. Identify the part of
   the {\tt polluteStochModel.xml} configuration that is used only by the EnKF
   run, and not by the others.
 \item Execute the Ensemble Kalman Filtering run by using the {\tt EnKF.oda}
   configuration.\\ Check how good the run is performing, by analyzing to what
   extent the filter has adjusted the predictions towards the
   observation.\\ Note that the Matlab result file in {\tt
     stochModel/output/work0} only contains a few time steps. Can you explain
   why?\\ So to compare the observations with the predictions you have to use
   the result file produced by the EnKF algorithm.
\end{itemize}

Now let us extend the filtering process by incorporating also the concentration
disposed by factory 1, and by including the observation locations downstream of
factory 1.

\begin{itemize}
 \item Make a copy of the involved config files, {\tt EnKF.oda} and \\{\tt
   polluteStochModel.xml} (you could call them {\tt EnKF2.oda} and\\ {\tt
   polluteStochModel2.xml}.\\ Adjust {\tt EnKF2.oda} so that it refers to the
   right stochastic model config file and produces a matlab result file with a
   recognizable name, e.g. {\tt enkf\_results2.m}.
 \item Now adjust {\tt polluteStochModel2.xml} in such a way that the filtering
   process is extended as described above.
 \item Run the filtering process by using the {\tt EnKF2.oda} configuration,
   and compare the results with the previous version of the filtering process.
\end{itemize}

